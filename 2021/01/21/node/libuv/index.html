<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="node,">










<meta name="description" content="最近一直在研究 node 的异步机制的实现，记录其中涉及到的一些问题。">
<meta name="keywords" content="node">
<meta property="og:type" content="article">
<meta property="og:title" content="Node异步libuv机制">
<meta property="og:url" content="http://yoursite.com/2021/01/21/node/libuv/index.html">
<meta property="og:site_name" content="小二，上酒">
<meta property="og:description" content="最近一直在研究 node 的异步机制的实现，记录其中涉及到的一些问题。">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2021-01-22T08:13:54.053Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Node异步libuv机制">
<meta name="twitter:description" content="最近一直在研究 node 的异步机制的实现，记录其中涉及到的一些问题。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/01/21/node/libuv/">





  <title>Node异步libuv机制 | 小二，上酒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小二，上酒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一如年少模样</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/21/node/libuv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="幽梦">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小二，上酒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Node异步libuv机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-21T13:06:58+08:00">
                2021-01-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  最近一直在研究 node 的异步机制的实现，记录其中涉及到的一些问题。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近一段时间不知道为啥，对于node性能机制非常好奇，就开始看各种书籍以及资料。所以就有了这一篇总结。</p>
<h4 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h4><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。<br>包括硬件事件，用户事件，计算机故障，断电等事件。</p>
<p>这里还涉及了一个 <code>中断程序入口映射表</code>，映射表在内核启动时自动加载，其中存储了对应的 中断的执行方法。不同的中断都对应了一个编号比如（0x80)就是常说的80中断，发送给cpu的指令只是中断的编号，<br>然后从中断映射表中查询出对应的回调策略处理程序。</p>
<p>CPU 通过接收 <code>中断控制器</code> 给到的信号进行处理中断请求，其中<code>中断控制器</code> 可以进行级联，中断控制器在主板上直接和硬件进行连接。外围设备触发事件之后，会 导致主板电流发现，告诉中断控制器产生中断，然后通过数据总线向CPU 完成中断请求IRQ.</p>
<h5 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h5><p>外围设备可以直接通过DMA直接访问内存。中断产生之后，外围设备可以通过DMA将数据复制到内存中，然后将数据信号送给CPU进行处理，发起一个中断IRQ。(一般外围设备都有自己的缓冲区进行存储数据。) CPU接收到 中断请求之后放弃现在当前的执行进程，将当前进程的数据保存到寄存器中，并将当前的寄存器保存到进程描述符汇中。（每一个进程都有自己的进程描述符）</p>
<p>然后 CPU，从用户态切换到内核态，从内存中获取数据进行处理, 执行结束之后，又切换会用户态，从进程描述符中恢复进程，继续执行。</p>
<h5 id="用户态，内核态"><a href="#用户态，内核态" class="headerlink" title="用户态，内核态"></a>用户态，内核态</h5><p>*nix 系统在启动的时候，会对内存进行分配，内核kernel使用部分为内核态，之外让出的部分供应用程序使用为用户态。<br>系统内核kernel中封装了对内存以及硬件操作的api。用户程序需要操纵内核态的数据，则需要通过内核kernel进行处理。这里就需要涉及从用户态切换到内核态。<br>而切换是需要代价的。</p>
<p>这里当应用程序需要调用内核程序时，会将 用户态保存的数据进行拷贝到内核态中，然后内核将数据放入到 <code>缓冲区</code> （输入缓冲区和输出缓冲区）中，然后内核在缓冲区写入完成之后，统一进行处理。<br>如果 内核 缓冲区 在被内核处理的过程中，用户态发了数据，那么用户态发送的数据将会被阻塞。直到缓冲区的数据被处理完成，才会继续处理新发送过来的数据。</p>
<p>用户应用程序如果在 <code>输出缓冲区</code> 数据没有发送完全之前关闭连接，那么数据不会丢失，缓冲区会继续发送，直到数据完成。但是如果是 <code>输入缓冲区</code> 的数据还没有发送完成，用户程序已经关闭，那么数据将会丢失。</p>
<h5 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h5><p>系统对内核进行保护，禁止高级应用程序直接操内核数据。</p>
<h5 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h5><p>用户态和内核态的切换。</p>
<h5 id="BIO-NIO"><a href="#BIO-NIO" class="headerlink" title="BIO/NIO"></a>BIO/NIO</h5><p>BIO 中的 <code>B</code> 就是 blocking的意思，没accept连接一个请求，都会进行阻塞。这种方式的话，一般来说都是使用多线程的方式。<br>但是如果1W个用户的话，直接开1W的线程的话，那么CPU估计就直接爆炸了，然后就是 线程上下文的切换也是非常耗时间的。（这里可以了解一下C10K的问题）</p>
<p>NIO 提供 非阻塞的接口。可以使用一个线程去调用select检查n个连接，是否有已经就绪的连接。。<br>NIO 一般还是需要调用到底层内核kernel的系统方法去实现。这就涉及到io多路复用。</p>
<h4 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h4><h5 id="select-poll"><a href="#select-poll" class="headerlink" title="select/poll"></a>select/poll</h5><p>select每次都需要进行内核态/用户态的切换，还需要检查select集合的fd，去检查连接的状态，如果有就绪的状态就直接返回，然后开始下一步的处理。<br>如果没有的话就处于阻塞状态，直到有连接就绪返回。select监听最多连接1024个。(每次检查都要切换用户态/内核态)</p>
<p>poll对select进行改进，主要是传入的参数进行了调整。主要用于解决最大连接1024这个问题。</p>
<h5 id="select-poll-存在的问题"><a href="#select-poll-存在的问题" class="headerlink" title="select/poll 存在的问题"></a>select/poll 存在的问题</h5><p>1 监听所有的连接文件描述符<br>2 主线程是死循环调用 select/poll函数，而且涉及到 用户态/内核态的数据拷贝过程。每一次调用都要进行数据拷贝。<br>3 select/poll 的返回值只是一个int,只能返回有几个连接产生了变化，没有表示具体哪一个产生了变化。</p>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><p>epoll 前面的e 应该就是event的意思，epoll 采用了事件驱动的方式进行管理连接。<br>EventPoll 结构分了两个区域，一部分用来存储连接fd列表，另一快就是已经就绪的列表，用来保存连接信息。存放连接的集合信息的结构采用的是红黑树的数据结构，因为有增删改查的需求。查找复杂为O(logn).</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">epoll_create // 创建 EventPoll 对象，用来保存epfd列表,会返回一个 epfd的文件号。</span><br><span class="line">epoll_ctrl // 通过eventpoll_id curd 操作eventPoll 列表,去检查需要增加或者修改的连接文件描述符。</span><br><span class="line">epoll_wait // 主要参数是 eventpoll_id 。</span><br></pre></td></tr></table></figure>

<h4 id="Node-事件循环"><a href="#Node-事件循环" class="headerlink" title="Node 事件循环"></a>Node 事件循环</h4><p>1 事件循环<br>2 浏览器事件循环<br>nodejs 与浏览器端的 Web API 版本的事件循环最大的不同的是：<br>在 nodejs 中事件循环不再是由单一个 task queue 和 micro-task queue 组成，而是由多个 阶段 phase 的多个回调函数队列 callbacks queues 组成一次事件循环 tick。 并且在每一个单独的阶段都存在一个单独的 回调函数 FIFO 队列。</p>
<p>3 process.nextTick</p>
<h4 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h4><p>这里的poll，应该是存在另外一个进程，进行 epoll_wait（多路复用epoll机制），然后每次去 poll 一下，看fd的队列中是否存在需要进行处理的队列，<br>如果有的话就进行执行，否则就直接返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">    ┌───────────────────────────┐</span><br><span class="line">┌─&gt; │           timers          │</span><br><span class="line">│   └─────────────┬─────────────┘</span><br><span class="line">│   ┌─────────────┴─────────────┐</span><br><span class="line">│   │   pending callbacks (I/O) │</span><br><span class="line">│   └─────────────┬─────────────┘</span><br><span class="line">│   ┌─────────────┴─────────────┐</span><br><span class="line">│   │       idle, prepare       │</span><br><span class="line">│   └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│   ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│   │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│   └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│   ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│   │           check           │</span><br><span class="line">│   └─────────────┬─────────────┘</span><br><span class="line">│   ┌─────────────┴─────────────┐</span><br><span class="line">└───┤      close callbacks      │</span><br><span class="line">    └───────────────────────────┘</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────────────┐ ┌─────────────────────────────────┐</span><br><span class="line">│                                                         libuv  | |                      JavaScript |</span><br><span class="line">│                                                                | |  ┌───────────────────────────┐  |</span><br><span class="line">│                               ┌───────────────────────────┐    | |  │        setTimeout         │  |</span><br><span class="line">│ Run expired timers ````````┌─&gt;│           timers          │````|`|``|        setInterval        |  |</span><br><span class="line">│                            │  └─────────────┬─────────────┘    | |  └───────────────────────────┘  |</span><br><span class="line">│                            │  ┌─────────────┴─────────────┐    | |  ┌───────────────────────────┐  |</span><br><span class="line">│ Run completed I/O handlers`│``│   pending I/O callbacks   │````|`|``│   some finished I/O work/ │  |</span><br><span class="line">│                            │  └─────────────┬─────────────┘    | |  │        I/O Errors         │  |</span><br><span class="line">│                            │  ┌─────────────┴─────────────┐    | |  └───────────────────────────┘  |</span><br><span class="line">│                            │  │       idle handlers       │    | |                                 |</span><br><span class="line">│                            │  └─────────────┬─────────────┘    | |                                 |</span><br><span class="line">│                            │  ┌─────────────┴─────────────┐    | |                                 |</span><br><span class="line">│ Some prep-work before `````│``│      prepare handlers     │    | |       ┌───────────────┐         |</span><br><span class="line">│ polling for I/O            │  └─────────────┬─────────────┘    | |       │   incoming:   │         |</span><br><span class="line">│                            │  ┌─────────────┴─────────────┐    | |       |  connections, │         |</span><br><span class="line">│ Wait for I/O to complete ``│``│          I/O Poll         │ &lt;──|─|───────┤   data, etc.  │         |</span><br><span class="line">│                            │  └─────────────┬─────────────┘    | |       └───────────────┘         |</span><br><span class="line">│                            │  ┌─────────────┴─────────────┐    | |  ┌───────────────────────────┐  |</span><br><span class="line">│ Some checking stuff ```````│``│       check handlers      │````|`|``│        setImmediate       │  |</span><br><span class="line">│ after polling for I/O      │  └─────────────┬─────────────┘    | |  └───────────────────────────┘  |</span><br><span class="line">│                            │  ┌─────────────┴─────────────┐    | |  ┌───────────────────────────┐  |</span><br><span class="line">│ Run any close handlers ````└──┤      close callbacks      │````|`|``│ *.on(&apos;close&apos;... handlers) │  |</span><br><span class="line">│                               └───────────────────────────┘    | |  └───────────────────────────┘  |</span><br><span class="line">|                                                                | |                                 |</span><br><span class="line">|                                                                | |                                 |</span><br><span class="line">└────────────────────────────────────────────────────────────────┘ └─────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_run</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> timeout;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Run one final update on the provider_idle_time in case uv__io_poll</span></span><br><span class="line"><span class="comment">     * returned because the timeout expired, but no events were received. This</span></span><br><span class="line"><span class="comment">     * call will be ignored if the provider_entry_time was either never set (if</span></span><br><span class="line"><span class="comment">     * the timeout == 0) or was already updated b/c an event was received.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    uv__metrics_update_idle_time(loop);</span><br><span class="line"></span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="comment">/* UV_RUN_ONCE implies forward progress: at least one callback must have</span></span><br><span class="line"><span class="comment">       * been invoked when it returns. uv__io_poll() can return without doing</span></span><br><span class="line"><span class="comment">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span></span><br><span class="line"><span class="comment">       * have pending timers that satisfy the forward progress constraint.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from</span></span><br><span class="line"><span class="comment">       * the check.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="timers"><a href="#timers" class="headerlink" title="timers"></a>timers</h5><p>主要用于setTimeout和setInterval.<br>但是timer的执行时机收到poll 阶段的影响。</p>
<blockquote>
<p>无论在 nodejs 还是 浏览器引擎，timer都不保证在到达时间后回调函数一定会被立即执行，它们只能保证在到达时间阈值后，尽快执行。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 每次循环迭代开始之前，开始设置开始时间</span></span><br><span class="line">  uv__update_time(loop);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UV_UNUSED(<span class="keyword">static</span> <span class="keyword">void</span> uv__update_time(<span class="keyword">uv_loop_t</span>* loop)) &#123;</span><br><span class="line">  <span class="comment">/* Use a fast time source if available.  We only need millisecond precision.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  loop-&gt;time = uv__hrtime(UV_CLOCK_FAST) / <span class="number">1000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__run_timers</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">heap_node</span>* <span class="title">heap_node</span>;</span></span><br><span class="line">  <span class="keyword">uv_timer_t</span>* handle;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环遍历timer时间节点遍历的最小堆</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 获取最小堆</span></span><br><span class="line">    heap_node = heap_min(timer_heap(loop));</span><br><span class="line">    <span class="comment">// 不存在</span></span><br><span class="line">    <span class="keyword">if</span> (heap_node == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    handle = container_of(heap_node, <span class="keyword">uv_timer_t</span>, heap_node);</span><br><span class="line">    <span class="comment">// 最小堆顶点如果 &gt; 当前时间，那么直接可以退出</span></span><br><span class="line">    <span class="keyword">if</span> (handle-&gt;timeout &gt; loop-&gt;time)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 否则开始循环执行</span></span><br><span class="line">    uv_timer_stop(handle);</span><br><span class="line">    uv_timer_again(handle);</span><br><span class="line">    handle-&gt;timer_cb(handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Assume this takes 95ms to complete</span></span><br><span class="line">  fs.readFile(<span class="string">'/path/to/file'</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// do someAsyncOperation which takes 95 ms to complete</span></span><br><span class="line">someAsyncOperation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do something that will take 10ms...</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - startCallback &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了避免 event loop 饿死，libuv 内部在pool阶段 有一个最大执行时间，超时之后必须返回去执行其他的阶段。</p>
</blockquote>
<h5 id="node-内置的定时器"><a href="#node-内置的定时器" class="headerlink" title="node 内置的定时器"></a>node 内置的定时器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TIMEOUT_MAX = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Timer constructor function.</span></span><br><span class="line"><span class="comment">// The entire prototype is defined in lib/timers.js</span></span><br><span class="line">function Timeout(callback, after, args, isRepeat, isRefed) &#123;</span><br><span class="line">  after *= <span class="number">1</span> <span class="comment">// Coalesce to number or NaN</span></span><br><span class="line">  <span class="keyword">if</span> (!(after &gt;= <span class="number">1</span> &amp;&amp; after &lt;= TIMEOUT_MAX)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (after &gt; TIMEOUT_MAX) &#123;</span><br><span class="line">      process.emitWarning(</span><br><span class="line">        `$&#123;after&#125; does <span class="keyword">not</span> fit into` +</span><br><span class="line">          ' a 32-bit signed integer.' +</span><br><span class="line">          '\nTimeout duration was set to 1.',</span><br><span class="line">        'TimeoutOverflowWarning'</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    after = <span class="number">1</span> <span class="comment">// Schedule on next tick, follows browser behavior</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._idleTimeout = after</span><br><span class="line">  <span class="keyword">this</span>._idlePrev = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">this</span>._idleNext = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">this</span>._idleStart = null</span><br><span class="line">  <span class="comment">// This must be set to null first to avoid function tracking</span></span><br><span class="line">  <span class="comment">// on the hidden class, revisit in V8 versions after 6.2</span></span><br><span class="line">  <span class="keyword">this</span>._onTimeout = nullv</span><br><span class="line">  <span class="keyword">this</span>._onTimeout = callback</span><br><span class="line">  <span class="keyword">this</span>._timerArgs = args</span><br><span class="line">  <span class="keyword">this</span>._repeat = isRepeat ? after : null</span><br><span class="line">  <span class="keyword">this</span>._destroyed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRefed) incRefCount()</span><br><span class="line">  <span class="keyword">this</span>[kRefed] = isRefed</span><br><span class="line"></span><br><span class="line">  initAsyncResource(this, 'Timeout')</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间阈值的取值范围是 1 ~ 231-1 ms，且为整数，如果数据不合法，会被重置为 1，所以 <code>setTimeout(fn, 0)</code> ,在node中其实是被重置为 <code>setTimeout(fn, 1)</code></p>
</blockquote>
<h5 id="pending-callbacks"><a href="#pending-callbacks" class="headerlink" title="pending callbacks"></a>pending callbacks</h5><p>执行一些操作系统的回调（system operations ），比如 TCP errors，比如，如果TCP socket尝试链接时，接收到一个 ECONNREFUSED 状态吗，一些 *nix系统就会等待去记录一个错误。这个步骤将会在pending callbacks阶段执行。</p>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>The poll phase has two main functions:</p>
<ul>
<li>Calculating how long it should block and poll for I/O, then</li>
<li>Processing events in the poll queue.</li>
</ul>
<p>个人觉得这里的 计算 io的阻塞和轮训时间，应该只是一个预估的过程，通过poll queue中的事件数量来进行一个大体的预估。</p>
<p>进入poll 阶段之后：</p>
<ul>
<li>如果 poll queue队列不为空，直接开始同步执行poll queue中回调，直到全部执行完或者触发最大的系统限制时间。</li>
<li>如果poll queue为空，则判断是否存在是否有被setImmediate绑定的回调，如果有则直接执行，否则event loop 会等待回调进行到当前poll queue中，并立即执行他们。</li>
</ul>
<p>在这之前 系统会去获取 timeout的值，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timeout = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">  timeout = uv_backend_timeout(loop);</span><br></pre></td></tr></table></figure>

<p>默认值为0，这个值会在之后被传入到epoll_wait中，0表示立即返回， -1 表示永久阻塞，&gt; 0 表示阻塞时间。<br>然后通过 uv_backend_timeout 进行计算得来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_backend_timeout</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// https://github.com/libuv/libuv/blob/v1.35.0/src/uv-common.c#L521-L523</span></span><br><span class="line">  <span class="comment">// http://docs.libuv.org/en/v1.x/guide/eventloops.html#stopping-an-event-loop</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!uv__has_active_handles(loop) &amp;&amp; !uv__has_active_reqs(loop))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;loop-&gt;idle_handles))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;closing_handles)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uv__next_timeout(loop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当事件循环 tick 被 uv_stop() 函数标记为停止#时，返回 0，即不阻塞。</li>
<li>当事件循环 tick 不处于活动状态时且不存在活动的 request 时返回 0，即不阻塞。</li>
<li>当 idle 句柄队列不为空时，返回 0，即不阻塞。</li>
<li>当 pending callbacks 的回调队列不为空时，返回 0，即不阻塞。</li>
<li>当存在 closing 句柄，即存在 close 事件回调时，返回 0，即不阻塞。</li>
</ul>
<p>如以上条件都不满足，则通过 <code>uv__next_timeout</code> 方法获取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv__next_timeout</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">heap_node</span>* <span class="title">heap_node</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uv_timer_t</span>* handle;</span><br><span class="line">  <span class="keyword">uint64_t</span> diff;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// libuv 计时器二叉最小堆的根节点为所有计时器中距离当前时间节点最近的计时器</span></span><br><span class="line">  heap_node = heap_min(timer_heap(loop));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处 true 条件为无限制的阻塞当前 poll 阶段</span></span><br><span class="line">  <span class="keyword">if</span> (heap_node == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* block indefinitely */</span></span><br><span class="line"></span><br><span class="line">  handle = container_of(heap_node, <span class="keyword">uv_timer_t</span>, heap_node);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若最近时间节点的计时器小于等于当前事件循环 `tick` 开始的时间节点</span></span><br><span class="line">  <span class="comment">// 那么不阻塞，并进入下一阶段，直至进入下一 `tick` 的 `timer` 阶段执行回调函数</span></span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;timeout &lt;= loop-&gt;time)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如 nodejs 文档中对 poll 阶段计算阻塞时间的描述</span></span><br><span class="line">  <span class="comment">// 以下语句用于计算当前 poll 阶段应该阻塞的时间</span></span><br><span class="line">  diff = handle-&gt;timeout - loop-&gt;time;</span><br><span class="line">  <span class="comment">// INT_MAX 在 limits.h 头文件中声明</span></span><br><span class="line">  <span class="keyword">if</span> (diff &gt; INT_MAX)</span><br><span class="line">    diff = INT_MAX;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>) diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意的是，以下的条件都是给予上面所属的5个条件都不成立的情况下，才会考虑一下的情况,(大体条件即为：不存在其他的事件阶段):</p>
<ul>
<li>若不存在任何计时器，那么当前事件循环 tick 中的 poll 阶段将 无限制阻塞。以实现一旦存在 I/O 回调函数加入到 poll queue 中即可立即得到执行。</li>
<li>若最近计时器时间节点小于等于开始时间，则表明在计时器二叉最小堆中 至少存在一个 过期的计时器，那么当前 poll 阶段的超时时间将被设置为 0，即表示 poll 阶段不发生阻塞。这是为了尽可能快的进入下一阶段，即尽可能快地结束当前事件循环 tick。在进入下一事件循环 tick 时，在 timer 阶段，上一 tick 中过期的计时器回调函数得以执行。</li>
<li>若最近计时器时间节点大于开始时间，则计算两个计时器之前的差值，且不大于 int 类型最大值。poll 将根据此差值来阻塞当前阶段，这么做是为了在轮询阶段，尽可能快的处理异步 I/O 事件。此时我们也可以理解为 事件循环 tick 始终有一种维持在 poll 阶段的倾向。</li>
</ul>
<blockquote>
<p>一旦poll queue为空，事件循环将检查是否已达到其时间阈值的timers。 如果一个或多个timer时间已经到达，则事件循环将返回到timers阶段以执行这些计时器的回调。</p>
</blockquote>
<h5 id="check"><a href="#check" class="headerlink" title="check"></a>check</h5><p>This phase allows a person to execute callbacks immediately after the poll phase has completed. If the poll phase becomes idle and scripts have been queued with setImmediate(), the event loop may continue to the check phase rather than waiting.</p>
<p>setImmediate() is actually a special timer that runs in a separate phase of the event loop. It uses a libuv API that schedules callbacks to execute after the poll phase has completed.</p>
<p>Generally, as the code is executed, the event loop will eventually hit the poll phase where it will wait for an incoming connection, request, etc. However, if a callback has been scheduled with setImmediate() and the poll phase becomes idle, it will end and continue to the check phase rather than waiting for poll events.</p>
<h5 id="close"><a href="#close" class="headerlink" title="close"></a>close</h5><p>如果 socket突然意外关闭，将会在此阶段调用close.否则将会在 process.nextTick中进行调用。</p>
<h5 id="setTimeout和setImmediate"><a href="#setTimeout和setImmediate" class="headerlink" title="setTimeout和setImmediate"></a>setTimeout和setImmediate</h5><ul>
<li>setImmediate() is designed to execute a script once the current poll phase completes.</li>
<li>setTimeout() schedules a script to be run after a minimum threshold in ms has elapsed.</li>
</ul>
<p>如果 setImmediate和setTimeout中没有涉及到io调用，那么他们的执行顺序取决与进程的调度。执行顺序存在不确定性。<br>如果涉及到 io 循环，那么 setImmediate将会永远都在setTimeout之前执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// timeout_vs_immediate.js</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;timeout&apos;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;immediate&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h5><p>process.nextTick() fires immediately on the same phase</p>
<blockquote>
<p>any time you call process.nextTick() in a given phase, all callbacks passed to process.nextTick() will be resolved before the event loop continues.<br>process.nextTick 会在每个阶段执行结束进行触发。process.nextTick可能会导致 event loop饿死。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncApiCall</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>, bar); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h5 id="process-nextTick-vs-setImmediate"><a href="#process-nextTick-vs-setImmediate" class="headerlink" title="process.nextTick() vs setImmediate()"></a>process.nextTick() vs setImmediate()</h5><p>We have two calls that are similar as far as users are concerned, but their names are confusing.</p>
<p>process.nextTick() fires immediately on the same phase<br>setImmediate() fires on the following iteration or ‘tick’ of the event loop。当前event loop执行完成，在close 阶段之前执行，其实就是poll阶段之后。</p>
<h4 id="libuv底层actor模型"><a href="#libuv底层actor模型" class="headerlink" title="libuv底层actor模型"></a>libuv底层actor模型</h4><h4 id="go协程模型"><a href="#go协程模型" class="headerlink" title="go协程模型"></a>go协程模型</h4><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>最后附上一下 uv__io_poll 的方法源码，其实就是调用了epoll的系统方法。<br>其中涉及对epoll_wait的调用，epoll_wait返回接收到时间的文件描述符fd。需要注意的是如果传入的 timeout为0的话，那么会立刻返回，如果为-1则会永远阻塞。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__io_poll</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* A bug in kernels &lt; 2.6.37 makes timeouts larger than ~30 minutes</span></span><br><span class="line"><span class="comment">   * effectively infinite on 32 bits architectures.  To avoid blocking</span></span><br><span class="line"><span class="comment">   * indefinitely, we cap the timeout and poll again if necessary.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Note that "30 minutes" is a simplification because it depends on</span></span><br><span class="line"><span class="comment">   * the value of CONFIG_HZ.  The magic constant assumes CONFIG_HZ=1200,</span></span><br><span class="line"><span class="comment">   * that being the largest value I have seen in the wild (and only once.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> max_safe_timeout = <span class="number">1789569</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> no_epoll_pwait_cached;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> no_epoll_wait_cached;</span><br><span class="line">  <span class="keyword">int</span> no_epoll_pwait;</span><br><span class="line">  <span class="keyword">int</span> no_epoll_wait;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[1024];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>* <span class="title">pe</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">e</span>;</span></span><br><span class="line">  <span class="keyword">int</span> real_timeout;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  <span class="keyword">uv__io_t</span>* w;</span><br><span class="line">  <span class="keyword">sigset_t</span> sigset;</span><br><span class="line">  <span class="keyword">uint64_t</span> sigmask;</span><br><span class="line">  <span class="keyword">uint64_t</span> base;</span><br><span class="line">  <span class="keyword">int</span> have_signals;</span><br><span class="line">  <span class="keyword">int</span> nevents;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">int</span> nfds;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">int</span> op;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> user_timeout;</span><br><span class="line">  <span class="keyword">int</span> reset_timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;nfds == <span class="number">0</span>) &#123;</span><br><span class="line">    assert(QUEUE_EMPTY(&amp;loop-&gt;watcher_queue));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;loop-&gt;watcher_queue)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;loop-&gt;watcher_queue);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line"></span><br><span class="line">    w = QUEUE_DATA(q, <span class="keyword">uv__io_t</span>, watcher_queue);</span><br><span class="line">    assert(w-&gt;pevents != <span class="number">0</span>);</span><br><span class="line">    assert(w-&gt;fd &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(w-&gt;fd &lt; (<span class="keyword">int</span>) loop-&gt;nwatchers);</span><br><span class="line"></span><br><span class="line">    e.events = w-&gt;pevents;</span><br><span class="line">    e.data.fd = w-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w-&gt;events == <span class="number">0</span>)</span><br><span class="line">      op = EPOLL_CTL_ADD;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      op = EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX Future optimization: do EPOLL_CTL_MOD lazily if we stop watching</span></span><br><span class="line"><span class="comment">     * events, skip the syscall and squelch the events after epoll_wait().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(loop-&gt;backend_fd, op, w-&gt;fd, &amp;e)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno != EEXIST)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">      assert(op == EPOLL_CTL_ADD);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We've reactivated a file descriptor that's been watched before. */</span></span><br><span class="line">      <span class="keyword">if</span> (epoll_ctl(loop-&gt;backend_fd, EPOLL_CTL_MOD, w-&gt;fd, &amp;e))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w-&gt;events = w-&gt;pevents;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sigmask = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;flags &amp; UV_LOOP_BLOCK_SIGPROF) &#123;</span><br><span class="line">    sigemptyset(&amp;sigset);</span><br><span class="line">    sigaddset(&amp;sigset, SIGPROF);</span><br><span class="line">    sigmask |= <span class="number">1</span> &lt;&lt; (SIGPROF - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(timeout &gt;= <span class="number">-1</span>);</span><br><span class="line">  base = loop-&gt;time;</span><br><span class="line">  count = <span class="number">48</span>; <span class="comment">/* Benchmarks suggest this gives the best throughput. */</span></span><br><span class="line">  real_timeout = timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv__get_internal_fields(loop)-&gt;flags &amp; UV_METRICS_IDLE_TIME) &#123;</span><br><span class="line">    reset_timeout = <span class="number">1</span>;</span><br><span class="line">    user_timeout = timeout;</span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reset_timeout = <span class="number">0</span>;</span><br><span class="line">    user_timeout = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* You could argue there is a dependency between these two but</span></span><br><span class="line"><span class="comment">   * ultimately we don't care about their ordering with respect</span></span><br><span class="line"><span class="comment">   * to one another. Worst case, we make a few system calls that</span></span><br><span class="line"><span class="comment">   * could have been avoided because another thread already knows</span></span><br><span class="line"><span class="comment">   * they fail with ENOSYS. Hardly the end of the world.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  no_epoll_pwait = uv__load_relaxed(&amp;no_epoll_pwait_cached);</span><br><span class="line">  no_epoll_wait = uv__load_relaxed(&amp;no_epoll_wait_cached);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">/* Only need to set the provider_entry_time if timeout != 0. The function</span></span><br><span class="line"><span class="comment">     * will return early if the loop isn't configured with UV_METRICS_IDLE_TIME.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (timeout != <span class="number">0</span>)</span><br><span class="line">      uv__metrics_set_provider_entry_time(loop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See the comment for max_safe_timeout for an explanation of why</span></span><br><span class="line"><span class="comment">     * this is necessary.  Executive summary: kernel bug workaround.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>) == <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &amp;&amp; timeout &gt;= max_safe_timeout)</span><br><span class="line">      timeout = max_safe_timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigmask != <span class="number">0</span> &amp;&amp; no_epoll_pwait != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> (pthread_sigmask(SIG_BLOCK, &amp;sigset, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (no_epoll_wait != <span class="number">0</span> || (sigmask != <span class="number">0</span> &amp;&amp; no_epoll_pwait == <span class="number">0</span>)) &#123;</span><br><span class="line">      nfds = epoll_pwait(loop-&gt;backend_fd,</span><br><span class="line">                         events,</span><br><span class="line">                         ARRAY_SIZE(events),</span><br><span class="line">                         timeout,</span><br><span class="line">                         &amp;sigset);</span><br><span class="line">      <span class="keyword">if</span> (nfds == <span class="number">-1</span> &amp;&amp; errno == ENOSYS) &#123;</span><br><span class="line">        uv__store_relaxed(&amp;no_epoll_pwait_cached, <span class="number">1</span>);</span><br><span class="line">        no_epoll_pwait = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nfds = epoll_wait(loop-&gt;backend_fd,</span><br><span class="line">                        events,</span><br><span class="line">                        ARRAY_SIZE(events),</span><br><span class="line">                        timeout);</span><br><span class="line">      <span class="keyword">if</span> (nfds == <span class="number">-1</span> &amp;&amp; errno == ENOSYS) &#123;</span><br><span class="line">        uv__store_relaxed(&amp;no_epoll_wait_cached, <span class="number">1</span>);</span><br><span class="line">        no_epoll_wait = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigmask != <span class="number">0</span> &amp;&amp; no_epoll_pwait != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> (pthread_sigmask(SIG_UNBLOCK, &amp;sigset, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update loop-&gt;time unconditionally. It's tempting to skip the update when</span></span><br><span class="line"><span class="comment">     * timeout == 0 (i.e. non-blocking poll) but there is no guarantee that the</span></span><br><span class="line"><span class="comment">     * operating system didn't reschedule our process while in the syscall.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SAVE_ERRNO(uv__update_time(loop));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">0</span>) &#123;</span><br><span class="line">      assert(timeout != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (reset_timeout != <span class="number">0</span>) &#123;</span><br><span class="line">        timeout = user_timeout;</span><br><span class="line">        reset_timeout = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We may have been inside the system call for longer than |timeout|</span></span><br><span class="line"><span class="comment">       * milliseconds so we need to update the timestamp to avoid drift.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">goto</span> update_timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == ENOSYS) &#123;</span><br><span class="line">        <span class="comment">/* epoll_wait() or epoll_pwait() failed, try the other system call. */</span></span><br><span class="line">        assert(no_epoll_wait == <span class="number">0</span> || no_epoll_pwait == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (reset_timeout != <span class="number">0</span>) &#123;</span><br><span class="line">        timeout = user_timeout;</span><br><span class="line">        reset_timeout = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Interrupted by a signal. Update timeout and poll again. */</span></span><br><span class="line">      <span class="keyword">goto</span> update_timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    have_signals = <span class="number">0</span>;</span><br><span class="line">    nevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Squelch a -Waddress-of-packed-member warning with gcc &gt;= 9. */</span></span><br><span class="line">      <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>* <span class="title">events</span>;</span></span><br><span class="line">        <span class="keyword">uv__io_t</span>* watchers;</span><br><span class="line">      &#125; x;</span><br><span class="line"></span><br><span class="line">      x.events = events;</span><br><span class="line">      assert(loop-&gt;watchers != <span class="literal">NULL</span>);</span><br><span class="line">      loop-&gt;watchers[loop-&gt;nwatchers] = x.watchers;</span><br><span class="line">      loop-&gt;watchers[loop-&gt;nwatchers + <span class="number">1</span>] = (<span class="keyword">void</span>*) (<span class="keyword">uintptr_t</span>) nfds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">      pe = events + i;</span><br><span class="line">      fd = pe-&gt;data.fd;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip invalidated events, see uv__platform_invalidate_fd */</span></span><br><span class="line">      <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      assert(fd &gt;= <span class="number">0</span>);</span><br><span class="line">      assert((<span class="keyword">unsigned</span>) fd &lt; loop-&gt;nwatchers);</span><br><span class="line"></span><br><span class="line">      w = loop-&gt;watchers[fd];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (w == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* File descriptor that we've stopped watching, disarm it.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Ignore all errors because we may be racing with another thread</span></span><br><span class="line"><span class="comment">         * when the file descriptor is closed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        epoll_ctl(loop-&gt;backend_fd, EPOLL_CTL_DEL, fd, pe);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Give users only events they're interested in. Prevents spurious</span></span><br><span class="line"><span class="comment">       * callbacks when previous callback invocation in this loop has stopped</span></span><br><span class="line"><span class="comment">       * the current watcher. Also, filters out events that users has not</span></span><br><span class="line"><span class="comment">       * requested us to watch.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      pe-&gt;events &amp;= w-&gt;pevents | POLLERR | POLLHUP;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Work around an epoll quirk where it sometimes reports just the</span></span><br><span class="line"><span class="comment">       * EPOLLERR or EPOLLHUP event.  In order to force the event loop to</span></span><br><span class="line"><span class="comment">       * move forward, we merge in the read/write events that the watcher</span></span><br><span class="line"><span class="comment">       * is interested in; uv__read() and uv__write() will then deal with</span></span><br><span class="line"><span class="comment">       * the error or hangup in the usual fashion.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * Note to self: happens when epoll reports EPOLLIN|EPOLLHUP, the user</span></span><br><span class="line"><span class="comment">       * reads the available data, calls uv_read_stop(), then sometime later</span></span><br><span class="line"><span class="comment">       * calls uv_read_start() again.  By then, libuv has forgotten about the</span></span><br><span class="line"><span class="comment">       * hangup and the kernel won't report EPOLLIN again because there's</span></span><br><span class="line"><span class="comment">       * nothing left to read.  If anything, libuv is to blame here.  The</span></span><br><span class="line"><span class="comment">       * current hack is just a quick bandaid; to properly fix it, libuv</span></span><br><span class="line"><span class="comment">       * needs to remember the error/hangup event.  We should get that for</span></span><br><span class="line"><span class="comment">       * free when we switch over to edge-triggered I/O.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (pe-&gt;events == POLLERR || pe-&gt;events == POLLHUP)</span><br><span class="line">        pe-&gt;events |=</span><br><span class="line">          w-&gt;pevents &amp; (POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pe-&gt;events != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Run signal watchers last.  This also affects child process watchers</span></span><br><span class="line"><span class="comment">         * because those are implemented in terms of signal watchers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (w == &amp;loop-&gt;signal_io_watcher) &#123;</span><br><span class="line">          have_signals = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          uv__metrics_update_idle_time(loop);</span><br><span class="line">          w-&gt;cb(loop, w, pe-&gt;events);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nevents++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reset_timeout != <span class="number">0</span>) &#123;</span><br><span class="line">      timeout = user_timeout;</span><br><span class="line">      reset_timeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_signals != <span class="number">0</span>) &#123;</span><br><span class="line">      uv__metrics_update_idle_time(loop);</span><br><span class="line">      loop-&gt;signal_io_watcher.cb(loop, &amp;loop-&gt;signal_io_watcher, POLLIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers] = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers + <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_signals != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;  <span class="comment">/* Event loop should cycle now so don't poll again. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nevents != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nfds == ARRAY_SIZE(events) &amp;&amp; --count != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Poll for more events but don't block this time. */</span></span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">update_timeout:</span><br><span class="line">    assert(timeout &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    real_timeout -= (loop-&gt;time - base);</span><br><span class="line">    <span class="keyword">if</span> (real_timeout &lt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    timeout = real_timeout;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://set.sh/post/200317-how-nodejs-event-loop-works" target="_blank" rel="noopener">从 libuv 看 nodejs 事件循环</a><br><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">The Node.js Event Loop, Timers, and process.nextTick()</a><br><a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">libuv Design overview</a><br><a href="https://drive.google.com/file/d/0B1ENiZwmJ_J2a09DUmZROV9oSGc/view" target="_blank" rel="noopener">2016 Node Interactive talk-compressed</a><br><a href="https://blog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1" target="_blank" rel="noopener">Handling IO</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/node/" rel="tag"># node</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/01/13/ts/5/" rel="next" title="TypeScript Class">
                <i class="fa fa-chevron-left"></i> TypeScript Class
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/26/fe/handle-error/" rel="prev" title="invokeWithErrorHandling">
                invokeWithErrorHandling <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">幽梦</p>
              <p class="site-description motion-element" itemprop="description">来者何人</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">81</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#背景"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算机基础知识"><span class="nav-number">2.</span> <span class="nav-text">计算机基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#中断"><span class="nav-number">2.1.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DMA"><span class="nav-number">2.2.</span> <span class="nav-text">DMA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#用户态，内核态"><span class="nav-number">2.3.</span> <span class="nav-text">用户态，内核态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#保护机制"><span class="nav-number">2.4.</span> <span class="nav-text">保护机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#切换"><span class="nav-number">2.5.</span> <span class="nav-text">切换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BIO-NIO"><span class="nav-number">2.6.</span> <span class="nav-text">BIO/NIO</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO-多路复用"><span class="nav-number">3.</span> <span class="nav-text">IO 多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#select-poll"><span class="nav-number">3.1.</span> <span class="nav-text">select/poll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#select-poll-存在的问题"><span class="nav-number">3.2.</span> <span class="nav-text">select/poll 存在的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#epoll"><span class="nav-number">3.3.</span> <span class="nav-text">epoll</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-事件循环"><span class="nav-number">4.</span> <span class="nav-text">Node 事件循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#libuv"><span class="nav-number">5.</span> <span class="nav-text">libuv</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#timers"><span class="nav-number">5.1.</span> <span class="nav-text">timers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#node-内置的定时器"><span class="nav-number">5.2.</span> <span class="nav-text">node 内置的定时器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pending-callbacks"><span class="nav-number">5.3.</span> <span class="nav-text">pending callbacks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#poll"><span class="nav-number">5.4.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#check"><span class="nav-number">5.5.</span> <span class="nav-text">check</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#close"><span class="nav-number">5.6.</span> <span class="nav-text">close</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setTimeout和setImmediate"><span class="nav-number">5.7.</span> <span class="nav-text">setTimeout和setImmediate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#process-nextTick"><span class="nav-number">5.8.</span> <span class="nav-text">process.nextTick</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#process-nextTick-vs-setImmediate"><span class="nav-number">5.9.</span> <span class="nav-text">process.nextTick() vs setImmediate()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#libuv底层actor模型"><span class="nav-number">6.</span> <span class="nav-text">libuv底层actor模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#go协程模型"><span class="nav-number">7.</span> <span class="nav-text">go协程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最后"><span class="nav-number">8.</span> <span class="nav-text">最后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考文档"><span class="nav-number">9.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">幽梦</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
